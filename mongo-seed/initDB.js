use csynapse

// init algos collection
db.algorithms.insert({"_id":"algorithms", "svm":{"description":"Support Vector Machines", "name":"Support Vector Machine", "type":"supervised",
"paramInfo":[{"name":"C","default":1,"type":"float","greater":"0","lessOrEqual":"none", "description":"Penalty parameter C of the error term."}]},
"knearest":{"description":"Knearest Neighbors", "name":"K-nearest Neighbors", "type":"supervised",
"paramInfo":[{"name":"n_neighbors","default":5,"type":"int","greater":"0","lessOrEqual":"none", "description":"Number of neighbors to use by default for k_neighbors queries."},
{"name":"metric","default":'euclidean',"type":"set","values":["euclidean","manhattan","chebyshev","minkowski","wminkowski","seuclidean","mahalanobis"],"description":"The metric to use when calculating distance between instances in a feature array."}]},
"guassNB":{"description":"Gaussian Naive Bayes", "name":"Gaussian Naive Bayes", "type":"supervised",
"paramInfo":[]},
"sgd":{"description":"Stochastic Gradient Descent", "name":"Stochastic Gradient Descent","type":"supervised",
"paramInfo":[{"name":"alpha","default":0.0001,"type":"float","greater":"0","lessOrEqual":"none", "description":"Constant that multiplies the regularization term. Used to compute the learning rate."}]},
"adaBoost":{"description":"Adaboost: Decision Trees", "name":"Adabost", "type":"supervised",
"paramInfo":[{"name":"learning_rate","default":1,"type":"float","greater":"0","lessOrEqual":"none", "description":"Learning rate shrinks the contribution of each classifier by learning_rate. There is a trade-off between learning_rate and n_estimators."},
{"name":"n_estimators","default":50,"type":"int","greater":"0","lessOrEqual":"none", "description":"The maximum number of estimators at which boosting is terminated. In case of perfect fit, the learning procedure is stopped early."}]},
"randomForest":{"description":"Random Forest", "name":"Random Forest","type":"supervised",
"paramInfo":[{"name":"criterion","default":"gini","type":"set","values":["gini","entropy"],"description":"The function to measure the quality of a split."},
{"name":"n_estimators","default":10,"type":"int","greater":"0","lessOrEqual":"none", "description":"The number of trees in the forest."},
{"name":"max_depth","default":"None","type":"int","greater":"0","lessOrEqual":"none", "description":"The maximum depth of the tree."}]},
"perceptron":{"description":"Perceptron", "name":"Perceptron","type":"supervised",
"paramInfo":[{"name":"penalty","default":"None","type":"set","values":["None","l2","l1","elasticnet"],"description":"The penalty (aka regularization term) to be used."},
{"name":"alpha","default":0.0001,"type":"float","greater":"0","lessOrEqual":"none", "description":"Constant that multiplies the regularization term if regularization is used."}]},
"nearestCentroid":{"description":"Nearest Centroid", "name":"Nearest Centroid","type":"supervised",
"paramInfo":[{"name":"metric","default":'euclidean',"type":"set","values":["euclidean","manhattan","chebyshev","minkowski","wminkowski","seuclidean","mahalanobis"],"description":"The metric to use when calculating distance between instances in a feature array."}]},
"passiveAggressive":{"description":"passiveAggressive", "name":"Passive Aggressive","type":"supervised",
"paramInfo":[{"name":"C","default":1,"type":"float","greater":"0","lessOrEqual":"none", "description":"Maximum step size (regularization)."}]},
"decisionTree":{"description":"Decision Tree", "name":"Decision Tree","type":"supervised",
"paramInfo":[{"name":"criterion","default":"gini","type":"set","values":["gini","entropy"],"description":"The function to measure the quality of a split."},
{"name":"max_features","default":"None","type":"int","greater":"0","lessOrEqual":"none", "description":"The number of features to consider when looking for the best split."},
{"name":"max_depth","default":"None","type":"int","greater":"0","lessOrEqual":"none", "description":"The maximum depth of the tree."}]},
"adaline":{"description":"adaline neural network", "name": "Adaline Neural Net","type":"supervised","paramInfo":[]},
"hebbian":{"description":"hebbian neural network", "name": "Hebbian Neural Net","type":"supervised","paramInfo":[]},
"multiLayerPerceptronSig":{"description":"multilayer perceptron with sigmoid", "name":"Multi-Layer Perceptron Sigmoid","type":"supervised","paramInfo":[]},
"multiLayerPerceptronTan":{"description":"multilayer perceptron with tan", "name":"Multi-Layer Perceptron Tan","type":"supervised","paramInfo":[]}})

// "leastSquares":{"description":"Least Squares", "name":"Least Square Regression","type":"regression"},
// "ridge":{"description":"Ridge Regression", "name":"Ridge Regression","type":"regression"},
// "lasso":{"description":"Lasso", "name": "Lasso","type":"regression"},
// "elasticNet":{"description":"Elastic Net", "name": "Elastic Net","type":"regression"},
// "lars":{"description":"Lars", "name":"Lars","type":"regression"},
// "orthogonalMatchingPursuit":{"description":"Orthongonal Matching Pursuit", "name":"Orthongonal Matching Pursuit","type":"regression"},
// "bayesianRidge":{"description":"Bayesian Ridge Regression", "name":"Bayesian Ridge Regression","type":"regression"},
// "logisticRegression":{"description":"Logistic Regression", "name": "Logistic Regression","type":"regression"},